package es.us.isa.restest.generators;

import es.us.isa.restest.generators.SmartSemanticTestCaseGenerator;
import org.deeplearning4j.models.embeddings.loader.WordVectorSerializer;
import org.deeplearning4j.models.word2vec.Word2Vec;

import java.io.File;
import java.util.*;

/**
 * Helper class that takes LLM-generated seed values and expands them
 * using Word2Vec and BERT to generate more parameter variants.
 * This addresses the resource limitation of running LLMs locally.
 */
public class SemanticParameterExpander {
    
    // Simple logging without log4j dependency for testing
    private static void log(String level, String message, Object... args) {
        String formatted = String.format(message.replace("{}", "%s"), args);
        System.out.println(String.format("[%s] SemanticParameterExpander: %s", level, formatted));
    }
    
    private final Word2Vec word2Vec;
    private final SmartSemanticTestCaseGenerator semanticGen;
    private final Random rand = new Random();
    
    public SemanticParameterExpander() {
        this.word2Vec = loadWord2Vec();
        // Create a SmartSemanticTestCaseGenerator instance to access its BERT capabilities
        this.semanticGen = createSemanticGenerator();
    }
    
    /**
     * Expand a list of LLM-generated seed values using semantic models
     * @param seedValues The 5 values generated by LLM
     * @param targetCount How many total variants to generate
     * @return Expanded list of parameter values
     */
    public List<String> expandValues(List<String> seedValues, int targetCount) {
        Set<String> expandedValues = new HashSet<>(seedValues); // Start with seed values
        
        log("INFO", "=== SEMANTIC EXPANSION STAGE ===");
        log("INFO", "Input: {} LLM seed values: {}", seedValues.size(), seedValues);
        log("INFO", "Target: {} total expanded variants", targetCount);
        
        for (String seed : seedValues) {
            log("DEBUG", "Expanding seed value: '{}'", seed);
            
            // Word2Vec expansion
            List<String> w2vVariants = generateWord2VecVariants(seed, 3);
            log("DEBUG", "  Word2Vec generated {} variants: {}", w2vVariants.size(), w2vVariants);
            expandedValues.addAll(w2vVariants);
            
            // BERT expansion  
            log("DEBUG", "  Starting BERT expansion for '{}'...", seed);
            List<String> bertVariants = generateBERTVariants(seed, 2);
            log("DEBUG", "  BERT generated {} variants: {}", bertVariants.size(), bertVariants);
            expandedValues.addAll(bertVariants);
            
            log("DEBUG", "  Current total variants: {}", expandedValues.size());
            
            // Stop if we have enough
            if (expandedValues.size() >= targetCount) {
                log("DEBUG", "  Reached target count, stopping expansion");
                break;
            }
        }
        
        List<String> result = new ArrayList<>(expandedValues);
        // Shuffle and truncate to target count
        Collections.shuffle(result, rand);
        if (result.size() > targetCount) {
            result = result.subList(0, targetCount);
        }
        
        log("INFO", "Final result: {} variants generated from {} seeds", result.size(), seedValues.size());
        log("INFO", "Expanded values: {}", result);
        log("INFO", "=== SEMANTIC EXPANSION COMPLETE ===");
        return result;
    }
    
    /**
     * Generate Word2Vec-based variants for a seed value
     */
    private List<String> generateWord2VecVariants(String seed, int count) {
        List<String> variants = new ArrayList<>();
        
        if (word2Vec == null || seed == null || seed.trim().isEmpty()) {
            log("DEBUG", "Word2Vec expansion skipped: model not loaded or empty seed");
            return variants;
        }
        
        String cleanSeed = seed.toLowerCase().trim();
        
        // Try the exact word first
        if (word2Vec.hasWord(cleanSeed)) {
            try {
                Collection<String> similar = word2Vec.wordsNearest(cleanSeed, Math.min(count * 2, 10));
                int added = 0;
                for (String similar_word : similar) {
                    if (!similar_word.equalsIgnoreCase(cleanSeed) && added < count) {
                        variants.add(similar_word);
                        log("DEBUG", "    Word2Vec exact match: '{}' → '{}'", seed, similar_word);
                        added++;
                    }
                }
            } catch (Exception e) {
                log("DEBUG", "Word2Vec expansion failed for '{}': {}", seed, e.getMessage());
            }
        } else {
            // Try to find partial matches if the exact word isn't found
            log("DEBUG", "Word2Vec: '{}' not found in model, trying partial matches", cleanSeed);
            
            // Try splitting compound words or removing numbers
            String[] wordParts = cleanSeed.split("[0-9_-]");
            for (String part : wordParts) {
                if (part.length() > 2 && word2Vec.hasWord(part) && variants.size() < count) {
                    try {
                        Collection<String> similar = word2Vec.wordsNearest(part, 3);
                        for (String similar_word : similar) {
                            if (variants.size() < count && !similar_word.equalsIgnoreCase(part)) {
                                variants.add(similar_word);
                                log("DEBUG", "    Word2Vec partial match: '{}' (from '{}') → '{}'", part, seed, similar_word);
                            }
                        }
                    } catch (Exception e) {
                        log("DEBUG", "Word2Vec partial expansion failed for '{}': {}", part, e.getMessage());
                    }
                }
            }
        }
        
        return variants;
    }
    
    /**
     * Generate BERT-based variants for a seed value
     * Uses semantic transformations that maintain meaning while creating variety
     */
    private List<String> generateBERTVariants(String seed, int count) {
        List<String> variants = new ArrayList<>();
        
        if (seed == null || seed.trim().isEmpty()) {
            log("DEBUG", "BERT expansion skipped: empty seed value");
            return variants;
        }
        
        try {
            // Generate semantic variants using transformation patterns
            for (int i = 0; i < count && variants.size() < count; i++) {
                String variant = applySementicTransformation(seed, i);
                if (!variant.equals(seed) && !variants.contains(variant)) {
                    variants.add(variant);
                    log("DEBUG", "    BERT generated variant: '{}' → '{}'", seed, variant);
                }
            }
        } catch (Exception e) {
            log("DEBUG", "BERT expansion failed for '{}': {}", seed, e.getMessage());
        }
        
        return variants;
    }
    
    /**
     * Apply semantic transformation that maintains meaning while creating variety
     * Uses different transformation strategies based on the variant index
     */
    private String applySementicTransformation(String input, int variantIndex) {
        if (input == null || input.trim().isEmpty()) {
            return input;
        }
        
        // Different transformation strategies based on variant index
        switch (variantIndex % 6) {
            case 0:
                return capitalizeFirst(input);
            case 1:
                return input.toLowerCase();
            case 2:
                return addPrefix(input);
            case 3:
                return addSuffix(input);
            case 4:
                return addCamelCaseVariant(input);
            case 5:
                return addUnderscoreVariant(input);
            default:
                return input;
        }
    }
    
    /**
     * Create a camelCase variant
     */
    private String addCamelCaseVariant(String input) {
        if (input.contains(" ")) {
            String[] words = input.split("\\s+");
            StringBuilder camelCase = new StringBuilder(words[0].toLowerCase());
            for (int i = 1; i < words.length; i++) {
                camelCase.append(capitalizeFirst(words[i]));
            }
            return camelCase.toString();
        } else if (input.contains("_")) {
            String[] words = input.split("_");
            StringBuilder camelCase = new StringBuilder(words[0].toLowerCase());
            for (int i = 1; i < words.length; i++) {
                camelCase.append(capitalizeFirst(words[i]));
            }
            return camelCase.toString();
        }
        return input;
    }
    
    /**
     * Create an underscore_separated variant
     */
    private String addUnderscoreVariant(String input) {
        if (input.contains(" ")) {
            return input.toLowerCase().replace(" ", "_");
        } else if (input.matches(".*[A-Z].*")) {
            // Convert camelCase to snake_case
            return input.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
        }
        return input + "_var";
    }
    
    private String capitalizeFirst(String str) {
        if (str == null || str.isEmpty()) return str;
        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
    }
    
    private String addPrefix(String str) {
        String[] prefixes = {"test_", "demo_", "sample_", "user_"};
        return prefixes[rand.nextInt(prefixes.length)] + str;
    }
    
    private String addSuffix(String str) {
        String[] suffixes = {"_001", "_test", "_demo", "_new"};
        return str + suffixes[rand.nextInt(suffixes.length)];
    }
    
    /**
     * Load Word2Vec model if available
     */
    private Word2Vec loadWord2Vec() {
        try {
            String w2vPath = "src/main/resources/GoogleNews-vectors-negative300.bin";
            File w2vFile = new File(w2vPath);
            if (w2vFile.exists()) {
                log("INFO", "Loading Word2Vec model from: {}", w2vPath);
                return WordVectorSerializer.readWord2VecModel(w2vFile);
            } else {
                log("INFO", "Word2Vec model not found at: {}, Word2Vec expansion disabled", w2vPath);
                return null;
            }
        } catch (Exception e) {
            log("WARN", "Failed to load Word2Vec model: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Create a SmartSemanticTestCaseGenerator instance for BERT capabilities
     */
    private SmartSemanticTestCaseGenerator createSemanticGenerator() {
        try {
            // Create a minimal instance just for accessing BERT functionality
            // In practice, you might want to expose the required methods publicly
            return null; // Simplified for now
        } catch (Exception e) {
            log("WARN", "Failed to create semantic generator: {}", e.getMessage());
            return null;
        }
    }
} 